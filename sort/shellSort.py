#!/usr/bin/env python
# coding:utf-8

"""
希尔排序：
    是对插入排序的升级的版本。(插入排序： 每次拿一个数在前面有序的数列中找到位置进行插入 )
    设置一个步长，一般为数列长度的一半。
    把数列按照步长分组，每组相同位置的数据进行选择排序，
    然后再把步长减小后分组，每组的相同位置元素进行选择排序
    一直步长减小到1位置，进行选择排序
    此时，数列顺序就排好了
    举个例子： 对于数列  8 7 6 5 4 3 2 1
    8个元素，我们按4为步长进行分组 分成了   8 7 6 5   4 3 2 1
        之后 每组相同位置元素进行插入排序，即把
        第一趟 8 4 (每组第一个位置)插入排序 整个数列变成： 4 7 6 5   8 3 2 1
        第二趟 7 3 (每组第二个位置)插入排序 整个数列变成:  4 3 6 5   8 7 2 1
        第三趟 6 2 (每组第三个位置) 进行插入排序后:       4 3 2 5   8 7 6 1
        第四趟 5 1 (每组第四个位置) 进行插入排序后:       4 3 2 1   8 7 6 5
    之后步长改为2  进行分组  4 3   2 1   8 7   6 5
        第一趟 4 2 8 6(每组第一个数)进行插入排序后整个数列：  2 3   4 1   6 7    8 5
        第二趟 3 1 7 5(每组第二个数)进行插入排序后整个数列:   2 1   4 3   6 5    8 7
        上述过程是便于理解，但是对于步长为2分组后，实际上的过程是： 4 3   2 1    8 7   6 5
         第一次 4 2 比  结果是  2 3   4 1   8 7   6 5
         第二次 3 1 比  结果是  2 1   4 3   8 7   6 5
         第三次 4 8 比  结果是  2 1   4 3   8 7   6 5
         。。。。持续下去
         实际上是按下标递增的方式进行的，但是每次只与它相邻组同位置元素进行比较，
            分组之后，每组相同位置元素不是一次进行插入排序结束再进行第二个相同位置排序
            比较顺序 是按照下表递增的方式进行的，但是比较的数据不是自己相邻的，而是相邻组相同位置的数据
    之后 步长改为1 进行分组 每个元素一组 进行插入排序： 1 2 3 4 5 6 7 8
    优点：设置步长，似的后边较大的元素能快速移动到前面来，前面大元素能快速移动到后面，省去了很多次比较的过程。
    时间复杂度: O(n)< x < O(n^2)
    稳定性: 不稳定的排序    按步长分组的时候，如果存在两个相等的数分在不同组里，插入排序后有可能本来在前面的数到后面去了
"""


def shell_sort(li):
    n = len(li)  # li列表中有n个数 下标从0到n-1
    gep = n // 2  # 设置初始步长进行分组
    # 当步长大于等于1的时候 一直进行分组的插入排序
    while gep >= 1:
        # 从gep的元素往后 一个一个元素对前面所有组跟自己处于相同位置的数进行插入排序
        for j in range(gep, n):
            i = j  # 标记下当前j的位置给i
            # 这层循环是为了回跳i所在位置，
            # 当一个新元素对前组同位置元素交换后，当前元素还需要跟再往前组的同位置元素比较决定是不是要交换
            # i - gep 能看我当前是不是第一组位置，如果是第一组位置，我前面没有组了，就不循环了，
            # 如果我是第三组，我会跳到前二组再跟第一组的相同位置元素进行比较
            while i - gep >= 0:
                # 如果当前数比前一组同位置数小，就交换数值
                if li[i] < li[i - gep]:
                    li[i], li[i - gep] = li[i - gep], li[i]
                    # 如果我和前一组同位置元素交换了，我需要继续与再往前一组同位置元素比较是否需要交换
                    # 这个操作是把我当前位置回跳到上一组的同位置
                    i -= gep
                # 如果没有发生数据交换，说明前面的不用再比较了，前面的一定都比我当前数小，跳出回跳位置的循环
                else:
                    break
        # 修改步长 缩小步长
        gep //= 2

if __name__ == '__main__':
    li = [5, 4, 3, 2, 1]
    shell_sort(li)
    print(li)
